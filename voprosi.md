Хорошо, это уже серьезный допрос, как на настоящей защите! Давай пройдемся по этим вопросам. Я буду исходить из твоего проекта, как я его вижу, и предлагать наиболее вероятные ответы, которые ты сможешь адаптировать.

**Вопросы по архитектуре:**

1.  **Какая представлена архитектура? Почему выбрана именно эта?**
    *   **Ответ:** В моем проекте представлена **клиент-серверная архитектура** с **многоуровневым (или трехзвенным, N-tier)** подходом, хотя и в упрощенном виде для веб-приложения.
        *   **Клиент:** Это браузер пользователя, который отображает HTML, CSS и выполняет JavaScript для интерактивности и AJAX-запросов.
        *   **Сервер приложений (логика):** Это PHP-скрипты, которые обрабатывают запросы от клиента, выполняют бизнес-логику (например, расчеты, проверки, взаимодействие с базой данных через классы `Database`, `ResidentialComplex`, `Mailer`). Сюда же относится и админ-панель.
        *   **Сервер данных (база данных):** Это MySQL, где хранится вся информация о жилых комплексах, квартирах, пользователях и т.д.
    *   **Почему выбрана:**
        *   **Стандарт для веб-приложений:** Это классическая и хорошо зарекомендовавшая себя архитектура для большинства сайтов и веб-сервисов.
        *   **Разделение ответственности:** Четко разделяет отображение (клиент), логику (PHP) и хранение данных (БД). Это упрощает разработку, тестирование и поддержку. Например, я могу изменить дизайн (клиентскую часть), не затрагивая логику на сервере, или оптимизировать запросы к БД, не меняя PHP-код.
        *   **Масштабируемость (относительная):** Хотя это не микросервисы, но такое разделение позволяет в будущем, при необходимости, масштабировать отдельные части (например, вынести БД на отдельный, более мощный сервер).
        *   **Простота для данного проекта:** Для задач моего проекта (сайт-каталог с админ-панелью) эта архитектура обеспечивает достаточную гибкость и мощность без излишней сложности.

2.  **Какие еще варианты архитектур рассматривались? Почему их не выбрали?**
    *   **Ответ:**
        *   **Монолитная архитектура (более строгий монолит):** Можно было бы написать все как единое PHP-приложение без четкого разделения на API, AJAX-обработчики, с сильной связью между компонентами.
            *   *Почему не выбрал:* Это усложнило бы AJAX-взаимодействие, сделало бы код менее гибким для изменений и повторного использования. Разделение на `complex_handler.php` для AJAX и отдельные PHP-страницы для отображения уже является шагом от чистого монолита к более структурированному подходу.
        *   **Микросервисная архитектура:** Разбить проект на множество маленьких, независимых сервисов (например, сервис для комплексов, сервис для авторизации, сервис для почты).
            *   *Почему не выбрал:* Для текущего масштаба проекта это было бы избыточно сложно. Микросервисы требуют более сложной настройки, управления развертыванием, межсервисного взаимодействия. Преимущества микросервисов (независимое масштабирование, разные технологии для разных сервисов) для данного проекта пока не перевешивают сложность их внедрения.
        *   **Чисто клиентское приложение (SPA - Single Page Application) с бэкендом как API:** Сделать весь интерфейс на JavaScript-фреймворке (React, Vue, Angular), а PHP оставить только для предоставления данных через API.
            *   *Почему не выбрал:* Хотя частичное использование API есть (`api/complexes.php`, `admin/ajax/complex_handler.php`), полный переход на SPA потребовал бы более глубоких знаний JavaScript-фреймворков и усложнил бы первоначальную разработку. Текущий подход с серверным рендерингом HTML для большинства страниц и AJAX для динамических частей был более прямолинейным для реализации.

**Вопросы по БД:**

1.  **Что такое ERD?**
    *   **Ответ:** ERD (Entity-Relationship Diagram) – это **диаграмма "Сущность-Связь"**. Представь, что это карта твоей базы данных.
        *   **Сущности (Entities):** Это главные "вещи" или "понятия", о которых ты хранишь информацию. В твоем проекте это, например, "ЖилойКомплекс", "Квартира", "ХарактеристикаКомплекса", "Администратор". На диаграмме они обычно изображаются прямоугольниками.
        *   **Атрибуты (Attributes):** Это свойства или характеристики каждой сущности. Например, у "ЖилогоКомплекса" есть атрибуты "Название", "Адрес", "Описание".
        *   **Связи (Relationships):** Это то, как сущности связаны друг с другом. Например, "Один ЖилойКомплекс может иметь Много Квартир" или "Одна Квартира принадлежит Одному ЖиломуКомплексу". На диаграмме связи изображаются линиями между прямоугольниками, часто с указанием типа связи (один-к-одному, один-ко-многим, многие-ко-многим).
    *   **Зачем нужна ERD:** Она помогает визуализировать структуру базы данных, понять, как данные организованы и связаны, еще до того, как ты начнешь создавать таблицы. Это помогает избежать ошибок в проектировании. (Ты можешь сказать, что для своего проекта ты держал ERD "в уме" или рисовал на бумаге, если не использовал специальный инструмент).

2.  **Какие бывают нормальные формы и зачем они существуют вообще?**
    *   **Ответ:** Нормальные формы (НФ) в базах данных – это как правила хорошего тона при организации твоих данных в таблицах. Их главная цель – **уменьшить избыточность данных и избежать аномалий** (проблем при добавлении, обновлении или удалении данных).
    *   **Основные нормальные формы (для ребенка):**
        *   **Первая нормальная форма (1НФ):** "Каждая ячейка в таблице должна содержать только одно значение, и не должно быть повторяющихся групп столбцов."
            *   *Просто:* В одной клетке таблицы – одно слово или число, а не целый список. Например, если у комплекса несколько телефонов, нельзя их все писать в одну ячейку "Телефоны". Нужно либо несколько колонок (Телефон1, Телефон2), либо, что лучше, вынести телефоны в отдельную связанную таблицу.
            *   **В твоем проекте:** Скорее всего, ты интуитивно следовал этому. Например, у квартиры одна площадь, одна цена.
        *   **Вторая нормальная форма (2НФ):** "Таблица должна быть в 1НФ, и все неключевые атрибуты должны полностью зависеть от всего составного первичного ключа." (Это актуально, если у тебя первичный ключ состоит из нескольких колонок).
            *   *Просто:* Если у тебя "паспорт" записи состоит из двух частей (например, "ID_Комплекса" + "Номер_Квартиры_В_Комплексе"), то все остальные данные об этой квартире (площадь, цена) должны зависеть от обеих этих частей вместе, а не только от одной из них.
            *   **В твоем проекте:** Если у тебя простые первичные ключи (один столбец `id`), то 2НФ обычно выполняется автоматически, если выполнена 1НФ.
        *   **Третья нормальная форма (3НФ):** "Таблица должна быть в 2НФ, и все неключевые атрибуты не должны зависеть от других неключевых атрибутов." (Нет транзитивных зависимостей).
            *   *Просто:* В таблице с квартирами не должно быть, например, информации о застройщике комплекса, если эта информация (имя застройщика, его телефон) зависит только от ID комплекса, а не от самой квартиры. Информацию о застройщике лучше хранить в таблице комплексов.
            *   **В твоем проекте:** Ты, вероятно, вынес информацию о комплексе (название, адрес) в таблицу `residential_complexes`, а в таблице `apartment_types` оставил только то, что напрямую относится к типу квартиры, плюс ссылку `complex_id`. Это соответствует 3НФ.
        *   **Есть и другие НФ (BCNF, 4НФ, 5НФ),** но для большинства проектов достаточно достичь 3НФ.
    *   **Зачем существуют:** Чтобы данные были чистыми, не дублировались, и чтобы при изменении данных в одном месте не приходилось менять их еще в десяти других (и что-то забыть).

3.  **Что такое аномалии и какие они бывают? Какие аномалии возникали при разработке? Как вы их исправляли?**
    *   **Ответ:** Аномалии – это "неприятности" или проблемы, которые могут случиться с данными в базе, если она плохо спроектирована (не нормализована).
    *   **Типы аномалий (для ребенка):**
        *   **Аномалия вставки:** "Не могу добавить новую информацию, потому что не хватает какой-то другой, связанной информации".
            *   *Пример:* Если бы ты хранил информацию о застройщике (ИмяЗастройщика, ТелефонЗастройщика) прямо в таблице квартир. Ты не смог бы добавить нового застройщика, пока у него не появится хотя бы одна квартира.
        *   **Аномалия удаления:** "Удалил одну информацию, а вместе с ней случайно удалилась и другая, нужная информация".
            *   *Пример:* Если бы информация о жилом комплексе (название, адрес) хранилась только в записях о его квартирах. Если ты удалишь последнюю квартиру в комплексе, ты потеряешь всю информацию о самом комплексе.
        *   **Аномалия обновления (модификации):** "Чтобы изменить одну и ту же информацию, мне нужно сделать это во многих местах, и я могу что-то пропустить или ошибиться".
            *   *Пример:* Если бы название жилого комплекса дублировалось в каждой записи о его квартире. Если комплекс переименуют, тебе придется менять название во всех записях квартир этого комплекса. Если пропустишь хоть одну – данные станут противоречивыми.
    *   **Возникали ли при разработке? Как исправляли?**
        *   (Здесь тебе нужно подумать о своем опыте. Даже если ты сразу проектировал хорошо, можешь сказать так): "На ранних этапах проектирования я обдумывал разные варианты структуры таблиц. Например, была мысль хранить все характеристики комплекса прямо в таблице `residential_complexes` в виде множества столбцов (`feature1`, `feature2`...). Но я понял, что это приведет к:
            *   **Аномалии вставки/удаления:** Если появится новый тип характеристики, придется менять структуру таблицы. Если у какого-то комплекса нет определенной характеристики, поле будет пустым.
            *   **Аномалии обновления:** Если название характеристики изменится, придется искать его по всем полям.
            Поэтому я решил вынести характеристики в отдельную таблицу `complex_features` (или аналогичную), связанную с `residential_complexes` по `complex_id`. Это позволило гибко добавлять любое количество характеристик каждому комплексу и избежало дублирования и пустот в основной таблице комплексов. Таким образом, я следовал принципам нормализации для предотвращения аномалий."
        *   Если ты использовал `GROUP_CONCAT` для характеристик, это само по себе не аномалия базы данных, а способ агрегации данных при выборке. Проблемы с `GROUP_CONCAT` (ограничение длины) – это уже проблема уровня запроса, а не структуры.

**Вопросы по стеку технологий:**
(Тут я дам общий шаблон, а ты подставишь свои конкретные инструменты, если они отличаются. Я предполагаю, что ты использовал стандартные вещи для веб-разработки).

1.  **PHP (Язык):**
    *   **Почему именно PHP? С чем сравнивали?**
        *   *Ответ:* "PHP был выбран из-за его широкой распространенности в веб-разработке, большого количества документации и готовых решений, а также моего предыдущего опыта с ним. Он хорошо подходит для создания динамических сайтов и взаимодействия с базами данных типа MySQL. Сравнивал с Python (Django/Flask) и Node.js. Python показался более требовательным к настройке окружения для простого веб-хостинга на тот момент, а Node.js, хоть и мощный для асинхронных задач, имел более крутую кривую обучения для традиционных CRUD-операций, которые были основными в моем проекте."
    *   **По каким критериям выбирали? Что еще подходит под те же критерии?**
        *   *Ответ:* "Критерии: простота развертывания на стандартном веб-хостинге, наличие большого сообщества, легкость интеграции с MySQL, достаточная производительность для задач проекта, мой текущий уровень владения языком. Под эти критерии также могли бы подойти Ruby on Rails (хотя он обычно предполагает более строгую структуру) или Perl (но он менее популярен сейчас для новых веб-проектов)."
    *   **Какие фреймворки и библиотеки? Почему они, с чем сравнивали, чем можно заменить? Почему не заменили?**
        *   *Ответ:*
            *   **Библиотеки:**
                *   **PHPMailer:** Для отправки почты. Выбрал, потому что это стандарт де-факто, надежная, поддерживает SMTP, HTML-письма, вложения, легко настраивается. Сравнивал с использованием встроенной функции `mail()`, но `mail()` сложнее в настройке для SMTP, хуже обрабатывает кодировки и заголовки, менее безопасна без должной настройки. Заменить можно было бы на Symfony Mailer или Swift Mailer, но для задач проекта функционала PHPMailer было более чем достаточно, и он уже был мне знаком.
                *   (Если использовал еще какие-то PHP-библиотеки, например, для работы с изображениями или PDF, упомяни их по той же схеме).
            *   **Фреймворки:** "В данном проекте я не использовал полноценный PHP-фреймворк (вроде Laravel, Symfony, Yii, CodeIgniter). Проект имеет относительно простую структуру, и я решил реализовать необходимую логику самостоятельно, чтобы лучше понять базовые принципы работы PHP в веб-приложениях, включая маршрутизацию (через `.htaccess` и структуру файлов), работу с базой данных (собственный класс `Database`) и обработку AJAX-запросов.
                *   *Если бы проект был сложнее или требовал бы более быстрого масштабирования и готовых решений для безопасности, ORM, шаблонизации, я бы рассмотрел использование фреймворка, например, Laravel из-за его популярности, богатой экосистемы и удобных инструментов, или Symfony для более сложных и кастомных решений. Но для текущих задач это было бы избыточным и увеличило бы порог вхождения."

2.  **JavaScript (и jQuery):**
    *   **Почему jQuery? С чем сравнивали? Чем можно заменить?**
        *   *Ответ:* "jQuery был выбран для упрощения работы с DOM (Document Object Model - структурой HTML-страницы), обработки событий и выполнения AJAX-запросов. На момент начала проекта он был очень популярен и у меня был опыт работы с ним. Он позволяет писать меньше кода для стандартных задач по сравнению с чистым JavaScript (vanilla JS) для некоторых операций.
        *   Сравнивал с написанием всего на чистом JavaScript. Чистый JS сейчас стал гораздо мощнее и удобнее (особенно с ES6+), и для многих задач jQuery уже не так необходим.
        *   Заменить можно было бы полностью на чистый JavaScript. Для более сложных интерфейсов можно было бы использовать React, Vue или Angular, но это бы сильно усложнило проект и архитектуру.
        *   Почему не заменил (если проект не новый): jQuery уже использовался, и переписывать существующий рабочий код на чистый JS не было первоочередной задачей, так как он справлялся со своими функциями."

3.  **MySQL (База данных):**
    *   **Почему MySQL? С чем сравнивали?**
        *   *Ответ:* "MySQL выбрана как одна из самых популярных реляционных баз данных для веб-приложений, особенно в связке с PHP. Она бесплатная, надежная, быстрая для большинства стандартных задач, имеет хорошую документацию и поддерживается большинством хостинг-провайдеров.
        *   Сравнивал с PostgreSQL (которая считается более мощной и строгой в плане типов данных и стандартов SQL, но может быть чуть сложнее в первоначальной настройке для простых проектов) и SQLite (которая является файловой БД, очень простой в использовании, но менее подходящей для многопользовательских веб-приложений с высокой нагрузкой или сложными связями). Для моего проекта (каталог с админкой) MySQL предоставила оптимальный баланс простоты, производительности и доступности."

4.  **Веб-сервер (Apache - если используется `.htaccess`):**
    *   **Почему Apache?**
        *   *Ответ:* "Скорее всего, мой проект развернут на хостинге, где по умолчанию используется Apache, так как я использую файл `.htaccess` для настройки ЧПУ и других директив. Apache — это очень распространенный, гибкий и хорошо документированный веб-сервер."
        *   (Если знаешь, что на Nginx, то ответ будет про Nginx и его конфигурационные файлы).

5.  **IDE (Среда разработки, например, VS Code, PhpStorm):**
    *   (Назови свою IDE). **Почему именно она?**
        *   *Ответ (пример для VS Code):* "Я использовал Visual Studio Code. Выбрал его из-за легковесности, огромного количества бесплатных расширений (для PHP, JavaScript, баз данных, Git и т.д.), встроенного терминала, хорошей подсветки синтаксиса и автодополнения. Он бесплатный и кроссплатформенный. Сравнивал с PhpStorm (более мощный, но платный и более ресурсоемкий) и Sublime Text (тоже легковесный, но VS Code показался удобнее из-за лучшей интеграции инструментов)."

6.  **Система контроля версий (Git):**
    *   **Что такое система контроля версий? Что такое репозиторий? Чем они отличаются? Какие бывают репозитории и системы контроля версий?**
        *   **Ответ для ребенка (про СКВ):** Представь, что ты рисуешь большую картину. Система контроля версий (СКВ) – это как волшебный альбом, который запоминает каждый твой шаг: вот ты нарисовал домик (сохранил – это **коммит**), потом добавил солнышко (еще коммит). Если ты вдруг испортил дерево, ты можешь "откатиться" к тому моменту, когда дерево было красивым. А еще, если вы рисуете картину вдвоем с другом, СКВ помогает вам не мешать друг другу и потом соединить ваши части рисунка.
        *   **СКВ (например, Git):** Это программа, которая отслеживает изменения в твоих файлах (коде).
        *   **Репозиторий:** Это папка с твоим проектом, за которой следит Git. Внутри этой папки есть скрытая папочка `.git` (если ты ее увидишь в корне проекта), где Git хранит всю историю изменений.
            *   **Локальный репозиторий:** Копия твоего проекта с историей на твоем компьютере.
            *   **Удаленный репозиторий:** Копия твоего проекта с историей на специальном сервере в интернете (например, на GitHub, GitLab, Bitbucket). Это нужно для совместной работы и как резервная копия.
        *   **Чем отличаются:** СКВ – это инструмент (молоток). Репозиторий – это то, над чем работает инструмент (доски, которые ты прибиваешь).
        *   **Какие бывают СКВ:** Самая популярная – **Git**. Раньше были SVN, CVS, Mercurial, но Git сейчас доминирует.
        *   **Какие бывают репозитории (сервисы хостинга репозиториев):** GitHub, GitLab, Bitbucket.

**Вопросы по методологии разработки (Agile):**
(Если ты не использовал конкретную методологию, будь честен. Можно сказать, что разработка велась итерационно с регулярной постановкой задач).

1.  **Что такое канбан-доска? К какой методологии планирования она относится?**
    *   **Ответ:** Канбан-доска – это визуальный инструмент для управления работой. Представь доску, разделенную на колонки, например: "Нужно сделать" (To Do), "В процессе" (In Progress), "Сделано" (Done). Каждая задача – это карточка, которая перемещается по колонкам по мере ее выполнения.
    *   Канбан-доска является ключевым элементом методологии **Канбан (Kanban)**, которая сама по себе является частью гибких подходов (Agile). Канбан фокусируется на ограничении незавершенной работы (Work In Progress - WIP) и улучшении потока задач.

2.  **Какие еще есть методологии? Почему выбрали именно эту (или как велась работа, если не по строгой методологии)?**
    *   **Ответ:**
        *   **Другие методологии Agile:** Scrum (короткие спринты, четкие роли, ежедневные встречи), XP (Экстремальное программирование - парное программирование, разработка через тестирование).
        *   **Традиционные (водопадные, Waterfall):** Строго последовательные этапы: анализ требований, проектирование, разработка, тестирование, внедрение. Менее гибкие.
        *   **Почему выбрали (или как работали):** "Для моего индивидуального проекта я не внедрял строгую методологию вроде Scrum. Однако я придерживался **гибких (Agile) принципов**:
            *   **Итеративная разработка:** Я разбивал работу на небольшие логические части (фичи) и реализовывал их последовательно.
            *   **Постановка задач:** Я составлял список задач (возможно, используя простой todo-список или менеджер задач вроде Trello, Notion, или даже просто текстовый файл), определял их приоритет. (Если использовал что-то вроде Trello, это уже похоже на простую Канбан-доску).
            *   **Регулярная проверка:** Я регулярно тестировал сделанное и вносил коррективы.
            Такой подход позволил мне гибко реагировать на возникающие идеи и проблемы без жестких рамок формальной методологии, что удобно для сольного проекта."

**Вопросы по тестированию:**
(Будь честен, какие виды тестирования ты РЕАЛЬНО проводил).

1.  **Какие виды тестирования использовались? Почему?**
    *   **Ответ:**
        *   **Ручное функциональное тестирование (Manual Functional Testing):** "Я проводил ручное тестирование всех основных функций сайта:
            *   Отправка форм (контактная, заявки) – проверял, что данные приходят на почту/сохраняются, что работает валидация.
            *   Работа админ-панели (CRUD-операции для комплексов, квартир, характеристик) – проверял добавление, редактирование, удаление.
            *   Авторизация администратора.
            *   Работа поиска (если есть).
            *   Корректность отображения информации на страницах комплексов и квартир.
            *   Почему: Это базовый вид тестирования, чтобы убедиться, что сайт делает то, что должен."
        *   **Тестирование пользовательского интерфейса (UI Testing) / Юзабилити-тестирование (Usability Testing) (неформальное):** "Я проверял, насколько удобно пользоваться сайтом, понятен ли интерфейс, все ли кнопки на своих местах, корректно ли отображается сайт на разных размерах экрана (адаптивность, благодаря Bootstrap)."
            *   Почему: Чтобы сайт был не только рабочим, но и удобным для пользователей.
        *   **(Если делал) Модульное тестирование (Unit Testing) (базовое):** "Возможно, при написании отдельных PHP-функций или методов классов я проверял их работу с разными входными данными, чтобы убедиться, что они корректно возвращают результат. Это было неформальное модульное тестирование."
            *   Почему: Чтобы быть уверенным в работоспособности отдельных маленьких "кирпичиков" кода.
        *   **(Если актуально) Тестирование безопасности (неформальное):** "Я проверял базовые аспекты безопасности, например, попытки прямого доступа к файлам админки, работу CSRF-защиты, валидацию данных для предотвращения XSS и базовых SQL-инъекций (благодаря подготовленным выражениям)."

2.  **Какие еще были варианты и почему их не использовали?**
    *   **Ответ:**
        *   **Автоматизированное тестирование (Automated Testing - Unit, Integration, E2E):** Написание специальных программ (тестов), которые автоматически проверяют работу сайта.
            *   *Почему не использовали:* "Для данного проекта внедрение полноценного автоматизированного тестирования (например, с использованием PHPUnit для юнит-тестов или Selenium/Cypress для E2E тестов) потребовало бы значительного дополнительного времени на изучение инструментов и написание самих тестов, что выходило за рамки учебного проекта. Ручного тестирования было достаточно для проверки основного функционала."
        *   **Нагрузочное тестирование (Load Testing):** Проверка, как сайт будет работать под большой нагрузкой (много одновременных пользователей).
            *   *Почему не использовали:* "Проект не предполагает изначально очень высоких нагрузок, поэтому специализированное нагрузочное тестирование не проводилось."
        *   **Тестирование совместимости (Compatibility Testing):** Проверка работы сайта в разных браузерах и на разных устройствах более формально.
            *   *Почему не использовали (формально):* "Я проверял в нескольких основных браузерах (Chrome, Firefox) и на разных размерах экрана, но формального тестирования совместимости по широкому списку конфигураций не проводил из-за ограниченности ресурсов."

3.  **Что такое тест-план? Зачем он нужен?**
    *   **Ответ:** Тест-план – это документ, который описывает **что, как, когда и кем** будет тестироваться. Это как генеральный план для всего процесса тестирования.
    *   **Зачем нужен:**
        *   Определяет объем тестирования.
        *   Определяет стратегию тестирования (какие виды тестов, какие инструменты).
        *   Определяет ресурсы (люди, время, ПО).
        *   Определяет критерии начала и окончания тестирования.
        *   Помогает всем участникам проекта понимать цели и задачи тестирования.
        *   (Для твоего проекта ты мог не писать формальный тест-план, но ты все равно планировал, *что* будешь проверять).

4.  **Что такое тест-кейс? Зачем он нужен? Что за результат "заблокирован", в каких случаях он ставится? приведите примеры.**
    *   **Ответ:** Тест-кейс – это **конкретный набор шагов, входных данных и ожидаемых результатов** для проверки определенной функции или части системы. Это как пошаговая инструкция для одного маленького эксперимента.
    *   **Зачем нужен:**
        *   Чтобы тестирование было системным и ничего не упустить.
        *   Чтобы разные тестировщики могли выполнять одни и те же проверки и получать сравнимые результаты.
        *   Для отслеживания покрытия тестами функционала.
    *   **Пример тест-кейса для твоего проекта:**
        *   **ID:** TC_LOGIN_001
        *   **Название:** Успешный вход администратора с корректными данными.
        *   **Предусловие:** Существует активный администратор с логином "admin" и паролем "password123".
        *   **Шаги:**
            1.  Открыть страницу `/admin/login.php`.
            2.  Ввести "admin" в поле "Логин".
            3.  Ввести "password123" в поле "Пароль".
            4.  Нажать кнопку "Войти".
        *   **Ожидаемый результат:** Пользователь успешно перенаправлен на главную страницу админ-панели (`/admin/index.php`). Появляется сообщение об успешном входе.
    *   **Результат тест-кейса "Заблокирован" (Blocked):**
        *   Этот статус ставится, когда тест-кейс **невозможно выполнить из-за другой ошибки (бага)** в системе, которая мешает дойти до шагов этого тест-кейса или проверить его ожидаемый результат.
        *   **Пример для твоего проекта:**
            *   У тебя есть тест-кейс "TC_COMPLEX_ADD_001: Добавление нового жилого комплекса".
            *   Но на сайте есть баг: кнопка "Добавить комплекс" на странице `/admin/complexes.php` неактивна или вообще отсутствует из-за другой ошибки.
            *   Ты не можешь даже начать выполнять шаги тест-кейса TC_COMPLEX_ADD_001, потому что тебе мешает этот предыдущий баг.
            *   В этом случае ты ставишь тест-кейсу TC_COMPLEX_ADD_001 статус "Заблокирован" и указываешь ID бага, который его блокирует. После исправления блокирующего бага, ты вернешься к этому тест-кейсу.

5.  **Что такое баг-репорт, зачем он нужен? Что такое серьезность и приоритет? Какие значения могут быть у этих параметров и в каких случаях они ставятся? По каким критериям вы выставили именно такие значения в своем баг репорте?**
    *   **Ответ:** Баг-репорт (отчет об ошибке) – это документ, который подробно описывает найденную ошибку (баг) в программе.
    *   **Зачем нужен:** Чтобы разработчики могли понять, в чем проблема, воспроизвести ее и исправить. Это основной способ коммуникации между тестировщиками и разработчиками по поводу ошибок.
    *   **Серьезность (Severity):** Насколько сильно ошибка **влияет на работу программы**.
        *   **Значения (примерные):**
            *   **S1 Блокирующая (Blocker):** Ошибка блокирует дальнейшую работу с основной функцией или всей системой, нет обходного пути. (Пример: Невозможно войти в админ-панель вообще).
            *   **S2 Критическая (Critical):** Серьезно нарушена основная бизнес-логика, потеря данных, уязвимость безопасности, но есть (возможно, сложный) обходной путь. (Пример: Новые комплексы сохраняются, но без всех указанных характеристик, часть данных теряется).
            *   **S3 Значительная (Major):** Часть основной бизнес-логики не работает корректно, но есть приемлемый обходной путь. (Пример: Форма обратной связи не отправляет телефон, но имя и сообщение уходят).
            *   **S4 Незначительная (Minor):** Ошибка в некритичном функционале, есть легкий обходной путь, или проблема UI, не влияющая на функциональность. (Пример: Кнопка "Отмена" на форме немного смещена).
            *   **S5 Тривиальная (Trivial):** Опечатка в тексте, небольшая проблема с версткой, не влияющая на общее восприятие. (Пример: Лишняя запятая в описании комплекса).
    *   **Приоритет (Priority):** Насколько **срочно нужно исправить ошибку** с точки зрения бизнеса или проекта. Определяется менеджером или тимлидом.
        *   **Значения (примерные):**
            *   **P1 Высокий (High):** Исправить как можно скорее, блокирует выпуск или важный функционал. (Часто совпадает с Blocker/Critical).
            *   **P2 Средний (Medium):** Нужно исправить в текущем релизе/итерации.
            *   **P3 Низкий (Low):** Можно исправить, если останется время, или отложить на потом.
    *   **Серьезность и Приоритет не всегда совпадают!** Например, опечатка на главной странице (S5 Trivial) может иметь высокий приоритет (P1 High), если это главная страница важного продукта перед показом инвесторам. А сложная ошибка в редко используемой функции (S3 Major) может иметь низкий приоритет (P3 Low), если сейчас важнее исправить другие вещи.
    *   **По каким критериям вы выставили значения в своем баг-репорте?** (Если ты писал баг-репорты). "Я оценивал серьезность исходя из того, какая часть функционала затронута и насколько это мешает основной цели сайта (например, если нельзя отправить заявку – это более серьезно, чем если картинка немного съехала). Приоритет я бы определил исходя из того, насколько эта ошибка видна пользователю и как сильно она портит общее впечатление или мешает выполнению ключевых сценариев."

6.  **Как исправили ошибку? Из-за чего она возникла? Что сделать, чтобы таких ошибок больше не возникало? Какие еще были ошибки? Как исправляли их?**
    *   (Это очень специфичный вопрос, на который ты должен ответить, основываясь на РЕАЛЬНЫХ ошибках, которые ты находил и исправлял в своем проекте).
    *   **Пример ответа:**
        *   "Да, была ошибка, когда при добавлении нового жилого комплекса через админ-панель, если не загрузить для него изображение, то на странице комплекса отображалась "битая" картинка и возникало PHP-предупреждение, так как скрипт пытался вывести путь к несуществующему файлу."
        *   **Как исправили:** "Я добавил проверку в PHP-код, который отображает информацию о комплексе. Перед тем как выводить тег `<img>`, я проверяю, существует ли файл изображения и не пустое ли имя файла в базе данных. Если изображения нет, я вывожу стандартную картинку-заглушку."
            ```php
            // Примерный код исправления (в файле отображения комплекса)
            if (!empty($complex['main_image_path']) && file_exists($_SERVER['DOCUMENT_ROOT'] . $complex['main_image_path'])) {
                echo '<img src="' . htmlspecialchars($complex['main_image_path']) . '" alt="' . htmlspecialchars($complex['name']) . '">';
            } else {
                echo '<img src="/images/placeholder.jpg" alt="Нет изображения">'; // Заглушка
            }
            ```
        *   **Из-за чего возникла:** "Ошибка возникла из-за недостаточной проверки наличия изображения перед его выводом. Я предполагал, что изображение всегда будет."
        *   **Что сделать, чтобы не возникало:** "Теперь я стараюсь всегда добавлять проверки на существование файлов и данных перед их использованием. Также можно было бы сделать поле загрузки изображения обязательным в форме добавления комплекса или установить изображение по умолчанию на уровне базы данных/логики, если оно не загружено."
        *   **Какие еще были ошибки:** "Также была проблема с CSRF-токеном, который иногда становился невалидным, если администратор долго держал открытой вкладку с формой. Я увеличил время жизни токена в `php/functions.php` и, возможно, добавил бы механизм обновления токена через AJAX для очень долгих сессий, если бы это было критично."

**Вопросы по безопасности:**

1.  **Какие угрозы у вашего продукта? Как технически реализована защита по каждой угрозе?**
    *   **Ответ:**
        *   **1. SQL-инъекции (Попытка внедрить вредный SQL-код в запросы к базе данных):**
            *   *Угроза:* Злоумышленник может попытаться изменить SQL-запрос, чтобы украсть данные, удалить их или получить несанкционированный доступ.
            *   *Защита:* **Использование подготовленных выражений (Prepared Statements)** во всех SQL-запросах, где используются пользовательские данные. Это реализовано в классе `php/Database.php` через метод `prepare()` и `bind_param()`. Данные от пользователя рассматриваются именно как данные, а не как часть SQL-команды.
                *   **Где смотреть:** `php/Database.php` (метод `prepare`), `php/admin_functions.php` (примеры использования `bind_param`).
        *   **2. XSS (Cross-Site Scripting - Межсайтовый скриптинг):**
            *   *Угроза:* Злоумышленник внедряет вредоносный JavaScript-код на страницы сайта, который выполняется в браузере других пользователей. Это может привести к краже сессий, изменению содержимого страницы и т.д.
            *   *Защита:* **Экранирование (санитизация) всех данных, выводимых на HTML-страницу**, которые пришли от пользователя или из базы данных. В моем проекте для этого используется функция `htmlspecialchars()` (обернутая в `sanitizeOutput()` в `php/functions.php`).
                *   **Где смотреть:** `php/functions.php` (функция `sanitizeOutput`), и во всех местах, где данные из PHP выводятся в HTML (например, при отображении названий комплексов, описаний, сообщений и т.д. – ты должен был использовать эту функцию).
        *   **3. CSRF (Cross-Site Request Forgery - Межсайтовая подделка запроса):**
            *   *Угроза:* Злоумышленник заставляет браузер авторизованного пользователя выполнить нежелательное действие на сайте (например, удалить комплекс) без его ведома, отправив поддельный запрос.
            *   *Защита:* **Использование CSRF-токенов.** Для каждой сессии пользователя генерируется уникальный секретный токен, который добавляется во все формы, изменяющие состояние. Сервер проверяет этот токен при получении запроса. Реализовано в `php/functions.php` (функции `generateCSRFToken`, `validateCSRFToken`) и используется в формах админ-панели и AJAX-обработчиках (например, в `admin/ajax/complex_handler.php`).
                *   **Где смотреть:** `php/functions.php`, `admin/ajax/complex_handler.php`, HTML-код форм в админке (должно быть скрытое поле с токеном).
        *   **4. Несанкционированный доступ к админ-панели:**
            *   *Угроза:* Посторонние лица могут получить доступ к управлению сайтом.
            *   *Защита:*
                *   **Проверка авторизации:** Функция `requireAdmin()` (в `php/admin_functions.php`) вызывается на всех страницах админки, требующих входа. Она проверяет сессию и делает дополнительный запрос к БД для валидации администратора.
                *   **Защита от подбора пароля:** Логирование попыток входа и временная блокировка после нескольких неудачных попыток (функции `checkLoginAttempts`, `logLoginAttempt` в `php/admin_functions.php`).
                *   **Безопасное хранение паролей (в идеале):** Хоть в `config.php` сейчас пароль в открытом виде, правильным решением было бы хеширование паролей администраторов в базе данных с использованием `password_hash()` и `password_verify()`.
        *   **5. Прямой доступ к PHP-файлам:**
            *   *Угроза:* Некоторые PHP-файлы не предназначены для прямого вызова через браузер.
            *   *Защита:* Использование `if (!defined('SECURE_ACCESS')) { die('Прямой доступ запрещен'); }` в начале таких файлов. Константа `SECURE_ACCESS` определяется в главном конфигурационном файле или точке входа.
        *   **6. Безопасность сессий:**
            *   *Угроза:* Перехват или подделка сессий.
            *   *Защита:* Настройки сессий в `php/config.php` (`session.cookie_httponly`, `session.use_only_cookies`, `session.cookie_samesite = 'Strict'`) помогают усложнить атаки на сессии. Также реализована проверка времени жизни сессии.

2.  **Для чего нужно соглашение о персональных данных?**
    *   **Ответ:** Соглашение (или политика) обработки персональных данных нужно для **соблюдения законодательства** (например, GDPR в Европе, ФЗ-152 "О персональных данных" в России) и для **информирования пользователей** о том, как их личная информация (имя, email, телефон и т.д.) будет собираться, использоваться, храниться и защищаться сайтом.
    *   **Ключевые моменты, которые оно объясняет пользователю:**
        *   **Какие данные собираются?** (Например, при заполнении контактной формы).
        *   **С какой целью собираются?** (Например, для обратной связи, для отправки информации о ЖК).
        *   **Как данные будут использоваться и кто имеет к ним доступ?**
        *   **Как долго данные будут храниться?**
        *   **Какие меры безопасности принимаются для защиты данных?**
        *   **Права пользователя** (например, право на доступ к своим данным, на их исправление или удаление).
        *   **Контакты ответственного лица** за обработку данных.
    *   Наличие такого соглашения (и обычно галочки "Я согласен с обработкой персональных данных" на формах) показывает, что вы ответственно относитесь к данным пользователей и действуете в рамках закона. Это также повышает доверие пользователей к вашему сайту.

---

Это очень объемный набор вопросов! Главное – не паниковать. Постарайся понять суть каждого вопроса и как он относится к твоему проекту. Если ты сам писал код и понимаешь его, ты сможешь ответить. Используй примеры из своего проекта – это всегда ценится.

Удачи!
